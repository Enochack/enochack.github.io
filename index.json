[{"content":" Coding is a process to learn and abstract. The more abstract, the closer to the nature and truth. The matrix is everywhere. Computer science is the study of computation: that is, how to represent and process information. Here are just a few of the concepts you might study:\nProblem solving: you’ll learn algorithms - that is, general strategies, such as divide and conquer,recursion,heuristics, greedy search, and randomized algorithms - that help you model, decompose, and solve any kind of problem. Logic: you will start to use precise and formal methods of thinking, including abstraction,boolean logic, number theory, and set theory, so you can solve problems in an air tight manner. Data: you will touch information theory and start asking questions like what is information? How do you represent it? How do you model the real world? Systems: how do you design and build complex systems that satisfy a set of requirements and constraints? Systems engineering is an essential topic in almost every business. Thinking: one of the best ways to understand the human mind is to try to replicate it. Topics like artificial intelligence, machine learning,computer vision, and natural language processing are at the forefront of not only computer science, but also biology, psychology, philosophy, and mathematics. ","permalink":"https://enochack.com/posts/coding-thinking/","summary":"Coding is a process to learn and abstract. The more abstract, the closer to the nature and truth. The matrix is everywhere. Computer science is the study of computation: that is, how to represent and process information. Here are just a few of the concepts you might study:\nProblem solving: you’ll learn algorithms - that is, general strategies, such as divide and conquer,recursion,heuristics, greedy search, and randomized algorithms - that help you model, decompose, and solve any kind of problem.","title":"Thoughts About Coding"},{"content":"Here is a set of common scala design patterns which I used in my coding time.\n1. Factory trait Vehicle { def drive } class Car extends Vehicle { override def drive { printf(\u0026#34;car bibi~\u0026#34;) } } class Bus extends Vehicle { override def drive { printf(\u0026#34;bus didi~\u0026#34;) } } class Truck extends Vehicle { override def drive { printf(\u0026#34;truck wowo~\u0026#34;) } } object Vehicle { def apply(kind: String) = kind match { case \u0026#34;car\u0026#34; = new Car() case \u0026#34;bus\u0026#34; = new Bus() case \u0026#34;truck\u0026#34; = new Truck() } } 2. Adapter import java.util.logging.Level import java.util.logging.Level._ object Adapter extends App { trait Log { def warn(msg: String) def error(msg: String) } final class Logger { def log(level: Level, message: String) = {} } implicit class LoggerToLogAdapter(logger: Logger) extends Log { def warn(msg: String) = { logger.log(WARNING, msg) } def error(msg: String) = { logger.log(INFO, msg) } } val log = new Logger() log.warn(\u0026#34;warn\u0026#34;) log.error(\u0026#34;error\u0026#34;) } 3. Decorator object Decorator extends App { trait OutStream { def write(b: Array[Byte]) } class FileOutputStream(path: String) extends OutStream { override def write(b: Array[Byte]) = { println(\u0026#34;do something\u0026#34;) } } trait Buffering extends OutStream { abstract override def write(b: Array[Byte]) = { println(\u0026#34;do something before super.write buffering\u0026#34;) super.write(b) } } new FileOutputStream(\u0026#34;hi\u0026#34;) .write(\u0026#34;hi fileoutput stream\u0026#34;.getBytes()) (new FileOutputStream(\u0026#34;hi\u0026#34;) with Buffering).write(\u0026#34;buffering\u0026#34;.getBytes()) } 4. Strategy object Strategy extends App { type Strategy = (Int, Int) =\u0026gt; Int class Context(s: Strategy) { def use(a: Int, b: Int) = s(a, b) } val add: Strategy = _ + _ println(new Context(add).use(2, 3)) } 5. Chain of Responsibility object Chain extends App { case class Event(source: String) trait Handler { def handle(event: Event) } class DefaultHandler extends Handler { def handle(event: Event) = { println(\u0026#34;default handler handle\u0026#34;)} } trait KeyboardHandler extends Handler { abstract override def handle(event: Event): Unit = { if (event.source == \u0026#34;keyboard\u0026#34;) { println(\u0026#34;keyboard handler handle\u0026#34;) } else { super.handle(event) } } } trait MouseHandler extends Handler { abstract override def handle(event: Event): Unit = { if (event.source == \u0026#34;mouse\u0026#34;) { println(\u0026#34;mouse handler handle\u0026#34;) } else { super.handle(event) } } } val handler = new DefaultHandler with KeyboardHandler with MouseHandler handler.handle(new Event(source = \u0026#34;a\u0026#34;)) handler.handle(new Event(source = \u0026#34;keyboard\u0026#34;)) handler.handle(new Event(source = \u0026#34;mouse\u0026#34;)) } 6. Dependency Injection object CI extends App { case class User() trait Repository { def save(user: User) } trait DefaultRepository extends Repository { def save(user: User) = { println(\u0026#34;save user\u0026#34;) } } trait UserService { self: Repository =\u0026gt; def create(user: User): Unit = { save(user) } } (new UserService with DefaultRepository).create(new User) } ","permalink":"https://enochack.com/posts/scala-design-patterns/","summary":"Here is a set of common scala design patterns.","title":"Scala Design Patterns Summary"}]